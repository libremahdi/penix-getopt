#include <pgetopt-4.2/pgetopt.h>

#include <stdio.h> // just for printf :)



int _create_func ( int, char ** );

int main ( int argc, char **argv )
{
    pinit *init = pinit_create (); // Creating a basic init structure for building the library tree.
    pclass *class = pclass_create ( &init, "main" ); // This function constructs a class instance. The first argument specifies the `init` address, while the second defines the `class` name.
    
    pinit_set_main_class ( &init, class ); // This function sets a class as the main class.
    /* The class that is set as main does not need to be explicitly referenced (or qualified) to use its parameters.
    */

    palw main_allowed_options [] = 
    /* `palw` is a type of variable, and `main_allowed_options` is an arbitrary (or custom) variable name. 
     * Its components are an ID and a parameter name.
    */ {
    //  { opt_id, opt_name },
        { 1, "h" },
        { 1, "help" },
        { 2, "o" },
        { 2, "output" },
        EOL
    };    

    pclass_set_allowed_options ( &class, main_allowed_options ); // This function assigns a PALW to a class.
                                                                 // The function's return value is of type usrerr.

    pclass_set_key ( &class, 2, NONE ); // This function designates an option ID as a key.
    /* In pgetopt, if you don't select an option to be a key, it is considered a Flag. If you configure 
       it as a key using the pclass_set_key function, it will become a Key.
     * Masters are a type of option that are not related to keys or flags, and their implementation is completely separate
    */ 

    palw master_avl [] = 
    /* We also use PALW to determine the allowed masters. The masters, just like other options, contain an opt_id. 
     * Masters do not differ from other options in terms of their clone option capability; by setting the same opt_id for two or more options, 
       you can achieve the clone option capability in masters.
    */ {
    //  { opt_id, opt_name },
        { 1 , "create"    },
        EOL
    };
    pinit_set_allowed_masters ( &init, master_avl ); // This function updates the PALW structure with master data.

    usrerr _error = pinit_parser ( &init, argc, argv ); // As its name suggests, this function performs part of the parsing operation.
    /* Specifically, this function initializes (or populates) the PAVl structure with the values consisting 
       of the arguments entered by the user.
     * usrerr is a simple two-part structure consisting of an error index and an error type. The error message is handled and generated by 
       the usererror_parser function, but you can do this manually. For more information, see the document manual.
    */

    if ( usererror_parser ( _error, argv ) ) return -1; // This function will issue the appropriate error type based on the value of the usrerr variable you defined.

    switch ( pinit_get_master_id ( init ) ) // This function returns the opt_id of the single, first master that the user used. There is no need for a loop because no processing is performed on the masters.
    /* Because `Pgetopt` always processes a single master of the user's data and returns all the subsequent data, a check is always performed in 
       the code's flow. That is, there is no need for a loop.
    */
    {
        case 1: // The number 1 is merely a simple identifier of option! (opt_id). for master
            if ( _create_func ( pinit_get_master_argc (init), pinit_get_master_argv (init) ) == -1 )
                return -1;
            break;
    }

    { // `pclass *class` parsing segment
        int opt_id, i=0;
        
        while ( ( opt_id = pclass_loop_get_opt_id ( class, i ) ) != -1 ) // this function returns the option ID of the options used by the user
        /* The function pclass_loop_get_opt_id iterates over (or traverses) the PAVl structure.
         * Its first argument is the corresponding class, and the second argument is an index 
           that helps with the PAVl traversal
         
         * If there is no data to traverse, the function returns a value of -1.
           ( Option IDs are always a positive number. )
         */ {
            switch ( opt_id )
            {
                case (1): // The number 1 is merely a simple identifier of option! (opt_id).
                    printf ("Help Page\n");
                    break;
                case (2):
                    for ( int vi=0 ; vi < pclass_get_key_size ( class, 2 ) ; ++vi ) // This function returns the count of a key's values.
                    {
                        printf ( "Output = %s\n", pclass_key_loop_get_value ( class, 2, vi ) ); // This function iterates over the values of a key.
                        /* Its first parameter is the class in which the key opt_id resides.
                         * The second parameter is the option ID that has been converted into the key (or keys).
                         * The third parameter is an index for the iteration (or traversal).
                        */
                    }
                    break;
            }
            ++i;
        }
    }
    
    pclass_free (&class); // Ensure `pclass` is freed after use to prevent memory leaks.
    pinit_free (&init); // Ensure `pinit` is freed after use to prevent memory leaks.
}

int _create_func ( int _argc, char **_argv )
{
    pinit *cr_init = pinit_create ();

    pclass *cr_main = pclass_create ( &cr_init, "main" );
    pinit_set_main_class ( &cr_init, cr_main );
    palw main_allowed_options [] = {
        { 1, "f" },
        EOL
    };
    pclass_set_allowed_options ( &cr_main, main_allowed_options );

    palw cr_master_avl [] = {
        { 1 , "file"    },
        EOL
    };
    pinit_set_allowed_masters ( &cr_init, cr_master_avl );

    usrerr cr_error = pinit_parser ( &cr_init, _argc, _argv );
    if ( usererror_parser ( cr_error, _argv ) ) return -1;

    switch ( pinit_get_master_id ( cr_init ) )
    {
        case 1:
            printf ("Create File\n");
            break;
    }

    int i=0, opt_id;
    while ( ( opt_id = pclass_loop_get_opt_id ( cr_main, i ) ) != -1 )
    {
        switch ( opt_id )
        {
            case (1):
                printf ("Create: this is 'f'\n");
                break;
        }
        ++i;
    }

    pclass_free ( &cr_main );
    pinit_free ( &cr_init );
}


/* Example Export :
 * If you provide no arguments to the software, you should see no output.

 $ ./example -h -o 1 create -f file
 Create File
 Create: this is 'f'
 Help Page
 Output = 1

*/